[
  {
    "topic": "1일차: 수평적 확장 vs 수직적 확장",
    "content": "TPM은 트래픽 증가 시 아키텍처 결정을 지원해야 합니다.\n- **Vertical Scaling (Scale-up):** 기존 서버의 CPU/RAM을 올리는 방식. 구현은 쉽지만 물리적 한계와 단일 장애점(SPOF) 위험이 있습니다.\n- **Horizontal Scaling (Scale-out):** 서버 대수를 늘리는 방식. 무한 확장이 가능하지만 로드 밸런서와 데이터 동기화 로직이 필요합니다.\n**핵심:** '언제' 수평적 확장이 필요한지 개발팀과 논의하는 능력이 중요합니다."
  },
  {
    "topic": "2일차: 로드 밸런싱 (Load Balancing)",
    "content": "수평적 확장의 핵심 기술입니다.\n- **역할:** 트래픽을 여러 서버로 분산하여 시스템 안정성을 높입니다.\n- **알고리즘:** Round Robin(순차적 배분), Least Connections(연결 적은 쪽 우선), IP Hash(특정 유저는 특정 서버로) 등이 있습니다.\n**핵심:** 로드 밸런서 자체가 죽었을 때를 대비한 이중화(Failover) 계획이 있는지 확인하는 것이 TPM의 역할입니다."
  },
  {
    "topic": "3일차: 마이크로서비스 아키텍처 (MSA)",
    "content": "거대한 서비스(Monolith)를 작은 단위로 쪼개는 방식입니다.\n- **장점:** 서비스별 독립 배포 가능, 장애 격리(한 곳이 죽어도 전체는 유지).\n- **단점:** 서비스 간 통신 복잡도 증가, 데이터 일관성 유지가 어려움.\n**핵심:** TPM은 서비스 간의 의존성(Dependency)을 지도처럼 파악하고 있어야 장애 시 빠르게 대응할 수 있습니다."
  },
  {
    "topic": "4일차: API 설계와 REST",
    "content": "시스템 간 대화 방식인 API를 이해해야 합니다.\n- **REST:** HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 자원을 관리하는 스타일입니다.\n- **중요성:** API 스펙이 변하면 협업 팀들 간에 병목이 생깁니다.\n**핵심:** TPM은 API 문서(Swagger 등)가 최신화되었는지, 하위 호환성(Backward Compatibility)이 깨지지 않는지 체크해야 합니다."
  },
  {
    "topic": "5일차: 데이터베이스 인덱스 (Index)",
    "content": "DB 성능 저하의 80%는 쿼리 속도에서 옵니다.\n- **원리:** 책의 '찾아보기'처럼 특정 데이터를 빠르게 찾기 위한 색인입니다.\n- **주의:** 인덱스가 많으면 조회(Read)는 빠르지만 쓰기(Write)는 느려집니다.\n**핵심:** 사용자 응답 시간이 느려진다면 '인덱스 최적화'가 필요한 시점인지 개발팀에 질문할 줄 알아야 합니다."
  }
]